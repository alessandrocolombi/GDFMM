---
title: "Moments of K"
author: "Alessandro Colombi"
date: "27/1/2023"
output: pdf_document
---


```{r}
suppressWarnings(suppressPackageStartupMessages(library(GDFMM)))
suppressWarnings(suppressPackageStartupMessages(library(ACutils)))
suppressWarnings(suppressPackageStartupMessages(library(tidyverse)))
suppressWarnings(suppressPackageStartupMessages(library(RColorBrewer)))
suppressWarnings(suppressPackageStartupMessages(library(salso)))
suppressWarnings(suppressPackageStartupMessages(library(wesanderson)))
suppressWarnings(suppressPackageStartupMessages(library(mcclust.ext)))
```



Moments of the Number of Clusters $K$ a priori

# One level

I first consider the case where $d=1$ and $n=100$

```{r}
n_j = 100
Npoints1 = 30
Npoints2 = 10
gamma_grid  = seq(0.01,2,length.out = Npoints1)
Lambda_grid = seq(1,10,length.out = Npoints2)
Exp_val = matrix(nrow = Npoints1,ncol = Npoints2)
Var = matrix(nrow = Npoints1,ncol = Npoints2)

for(i in 1:Npoints1 ){
  for(j in 1:Npoints2){
    Moments = Expected_prior(n_j = n_j, gamma = gamma_grid[i], type = "distinct", 
                             prior = "Poisson", lambda = Lambda_grid[j])
    Exp_val[i,j] = Moments$Mean
    Var[i,j] = Moments$Variance
  }
}



Lambda_names = unlist(  lapply( as.list(as.character(round(Lambda_grid, digits = 1))),  
                                FUN = function(x){ paste0( "Lambda", "=",x)  }
                              )
                     )

gamma_names = unlist(  lapply( as.list(as.character(round(gamma_grid, digits = 2))),  
                                FUN = function(x){ paste0( "gamma", "=",x)  }
                              )
                     )

rownames(Exp_val) <- rownames(Var) <- gamma_names
colnames(Exp_val) <- colnames(Var) <- Lambda_names
```


Guardo la media
```{r}
#Exp_val
round(Exp_val, digits = 3)
```


* Valori piccoli di $\gamma$ hanno un certo impatto, che però svanisce al crescere di $\gamma$.
* La soglia da cui in poi $\gamma$ non impatta più, dipende da $\Lambda$, più crece $\Lambda$, più valori di $\gamma$ hanno effetto
* Da quella soglia in poi, $E[K]$ è determinato solo da $\Lambda$

```{r}
#Var
round(Var, digits = 3)
```

* Per quanto riguarda la varianza, l'impatto di $\gamma$ sembra trascurabile rispetto a $\Lambda$, soprattutto per $\gamma>1$.
* In più, la varianza sembra essere sempre simile alla media, cosa che può dato che $\Lambda$ è distribuita con una Poisson. Potrebbe tuttavia essere una limitazione.


## Distribution for $\Lambda$ fixed

Fisso $\Lambda = 4$ e guardo la distribuzione del numero di cluster al variare di $\gamma$
```{r}
Npoints = 100
Lambda = 4
gamma_grid  = seq(0.03,3,length.out = Npoints)
prob_k = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:n_j ){
    prob_k[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                    gamma = gamma_grid[i],
                                    prior = "Poisson", 
                                    lambda = Lambda)
    #if(sum(prob_k)>=threshold)
      #break
  }
}
```

La curva nera è la prima, quella con $\gamma$ minore

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k), type = "l", lwd = 2,xlim = c(0,20),lty = 1,
          col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
          main = paste0(  paste0( "Distribution of K for Lambda=4 and gamma varying") ))
```

Come mi aspettavo, fissato $\Lambda$ ci sono delle differenze iniziali, che diventano poi minime quando la media di avvicina a 4.


Rifaccio con $\Lambda = 20$
```{r}
Npoints = 100
Lambda = 20
gamma_grid  = seq(0.01,2,length.out = Npoints)
prob_k2 = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:n_j ){
    prob_k2[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                    gamma = gamma_grid[i],
                                    prior = "Poisson", 
                                    lambda = Lambda)
    #if(sum(prob_k)>=threshold)
      #break
  }
}
```

La curva nera è la prima, quella con $\gamma$ minore

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k2), type = "l", lwd = 2,xlim = c(0,40), lty = 1,
         col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
         main = paste0(  paste0( "Distribution of K for Lambda=20 and gamma varying") ))
```

La variabilità sembra essere sempre simile

## Distribution for $\gamma$ fixed

Ora faccio l'esperimento inverso, tengo fisso $\gamma$ e faccio variare $\Lambda$.

### gamma = 2

```{r}
Npoints = 20
gamma = 2
Lambda_grid  = seq(1,20,length.out = Npoints)
prob_k3 = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:n_j ){
    prob_k3[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                     gamma = gamma,
                                     prior = "Poisson", 
                                     lambda = Lambda_grid[i])
    #if(sum(prob_k)>=threshold)
      #break
  }
}
```

La curva nera è la prima, quella con $\Lambda$ minore. Ogni curva, corrisponde ad aumentare $\Lambda$ di 1.

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k3), type = "l", lwd = 2,xlim = c(0,35),lty = 1,
         col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
         main = paste0(  paste0( "Distribution of K for gamma=2 and Lambda varying") ))
```


### gamma = 0.1

Ripeto lo stesso esperimento abbassando il valore di $\gamma$. Ogni curva, corrisponde ad aumentare $\Lambda$ di 1.

```{r}
Npoints = 20
gamma = 0.1
Lambda_grid  = seq(1,20,length.out = Npoints)
prob_k3 = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:n_j ){
    prob_k3[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                     gamma = gamma,
                                     prior = "Poisson", 
                                     lambda = Lambda_grid[i])
    #if(sum(prob_k)>=threshold)
      #break
  }
}
```

La curva nera è la prima, quella con $\Lambda$ minore

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k3), type = "l", lwd = 2,xlim = c(0,35), lty = 1,
         col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
         main = paste0(  paste0( "Distribution of K for gamma=0.1 and Lambda varying") ))
```

Al crescere di $\Lambda$ le curve si spostano ma molto più lentamente.

**CONCLUSIONI**

* $\Lambda$ è una sorta di upper bound per il numero di cluster, $E[K]<\Lambda$.
* $\gamma$ aiuta a ridurre $E[K]$ al di sotto della soglia $\Lambda$. Partendo da valori di $\gamma$ piccoli:
  - Se $\gamma$ cresce, cresce anche $E[K]$ ma rispettando il vincolo $E[K]<\Lambda$. Quindi da un certo valore di $\gamma$ in poi, anche aumentando $\gamma$ non cambia niente.
* **Non possiamo controllare sia media che varianza**. Possiamo fissare la media al valore che vogliamo ma non stringere significativamente la varianza attorno a quel valore, quindi non possiamo essere troppo informativi sul numero di cluster che vogliamo.



# Two levels

I repeat the experiment when $d=2$. Now, the process parameters are $\gamma_1,\gamma_2, \Lambda$.

I consider an unbalanced number of points in the two levels, $n=(100,50)$.


## Grid for fixed Lambda 

Fisso $\Lambda = 6$
```{r}
n_j = c(100,50)
Lambda = 6

Npoints = 20
gamma1_grid  = seq(0.01,1,length.out = Npoints)
gamma2_grid  = seq(0.01,1,length.out = Npoints)

#Lambda_grid = seq(2,10,length.out = Npoints)

Exp_val = matrix(nrow = Npoints,ncol = Npoints)
Var     = matrix(nrow = Npoints,ncol = Npoints)

for(i in 1:Npoints){
  for(j in 1:Npoints){
    Moments = Expected_prior(n_j = n_j, gamma = c(gamma1_grid[i],gamma2_grid[j]), 
                             type = "distinct", 
                             prior = "Poisson", lambda = Lambda )
    Exp_val[i,j] = Moments$Mean
    Var[i,j]     = Moments$Variance
  }
}



gamma1_names = unlist(  lapply( as.list(as.character(round(gamma1_grid, digits = 2))),  
                                FUN = function(x){ paste0( "gamma1", "=",x)  }
                              )
                     )
gamma2_names = unlist(  lapply( as.list(as.character(round(gamma2_grid, digits = 2))),  
                                FUN = function(x){ paste0( "gamma2", "=",x)  }
                              )
                     )

rownames(Exp_val) <- rownames(Var) <- gamma1_names
colnames(Exp_val) <- colnames(Var) <- gamma2_names
```


Guardo la media
```{r}
#Exp_val
round(Exp_val, digits = 3)
```

* L'impatto di $\gamma_1$ e $\gamma_2$ è un'estensione di quello che abbiamo visto nel caso $d=1$.
* $E[K]$ cresce più velocemente con $\gamma_1$ che con $\gamma_2$, ovvero con il livello più numeroso.
* Un'importante differenza è che ora l'upper bound per $E[K]$ sembra essere $\Lambda+1$ e non solo $\Lambda$ 

Guardo anche la varianza
```{r}
#Var
round(Var, digits = 3)
```



## Grid for fixed $\gamma_1=\gamma_2$ 

```{r}
n_j = c(100,50)

Npoints1 = 30
Npoints2 = 10
Lambda_grid  = seq(1,10,length.out = Npoints2)
gamma_grid  = seq(0.01,1,length.out = Npoints1)

#Lambda_grid = seq(2,10,length.out = Npoints)

Exp_val = matrix(nrow = Npoints1,ncol = Npoints2)
Var     = matrix(nrow = Npoints1,ncol = Npoints2)

for(i in 1:Npoints1){
  for(j in 1:Npoints2){
    Moments = Expected_prior(n_j = n_j, gamma = c(gamma_grid[i],gamma_grid[i]), 
                             type = "distinct", 
                             prior = "Poisson", lambda = Lambda_grid[j] )
    Exp_val[i,j] = Moments$Mean
    Var[i,j]     = Moments$Variance
  }
}



Lambda_names = unlist(  lapply( as.list(as.character(round(Lambda_grid, digits = 1))),  
                                FUN = function(x){ paste0( "Lambda", "=",x)  }
                              )
                     )
gamma2_names = unlist(  lapply( as.list(as.character(round(gamma_grid, digits = 2))),  
                                FUN = function(x){ paste0( "gamma1=gamma2", "=",x)  }
                              )
                     )

rownames(Exp_val) <- rownames(Var) <- gamma2_names
colnames(Exp_val) <- colnames(Var) <- Lambda_names
```


Guardo la media
```{r}
#Exp_val
round(Exp_val, digits = 3)
```

Il comportamento è simile a prima ma lo spazio di manovra sembra molto più limitato, i valori convergono molto più velocemente all'upper bound dato da $E[K]$.


Guardo la varianza
```{r}
#Var
round(Var, digits = 3)
```


## Distribution for $\Lambda$ fixed and equal $\gamma$s

Fisso $\Lambda = 4$ e guardo la distribuzione del numero di cluster al variare di $\gamma_1 = \gamma_2$
```{r}
Npoints = 50
Lambda = 4
gamma_grid  = seq(0.01,1,length.out = Npoints)
prob_k = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:max(n_j) ){
    prob_k[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                    gamma = c(gamma_grid[i],gamma_grid[i]),
                                    prior = "Poisson", 
                                    lambda = Lambda)
    #if(sum(prob_k)>=threshold)
      #break
  }
}

```

La curva nera è la prima, quella con $\gamma$ minore

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k), type = "l", lwd = 2,xlim = c(0,20),lty = 1,
          col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
          main = paste0(  paste0( "Distribution of K for Lambda=4 and gamma varying") ))
```

Ripeto per $\Lambda = 10$
```{r}
Npoints = 50
Lambda = 10
gamma_grid  = seq(0.01,1,length.out = Npoints)
prob_k = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:max(n_j) ){
    prob_k[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                    gamma = c(gamma_grid[i],gamma_grid[i]),
                                    prior = "Poisson", 
                                    lambda = Lambda)
    #if(sum(prob_k)>=threshold)
      #break
  }
}

```

La curva nera è la prima, quella con $\gamma$ minore

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k), type = "l", lwd = 2,xlim = c(0,20),lty = 1,
          col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
          main = paste0(  paste0( "Distribution of K for Lambda=10 and gamma varying") ))
```


## Distribution for $\gamma$ fixed

Ora faccio l'esperimento inverso, tengo fisso $\gamma$ e faccio variare $\Lambda$.

### gamma1 = gamma2 = 2

```{r}
Npoints = 20
gamma1 <- gamma2 <- 2
Lambda_grid  = seq(1,20,length.out = Npoints)
prob_k3 = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:max(n_j) ){
    prob_k3[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                     gamma = c(gamma1,gamma2),
                                     prior = "Poisson", 
                                     lambda = Lambda_grid[i])
    #if(sum(prob_k)>=threshold)
      #break
  }
}
```

La curva nera è la prima, quella con $\Lambda$ minore. Ogni curva, corrisponde ad aumentare $\Lambda$ di 1.

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k3), type = "l", lwd = 2,xlim = c(0,35),lty = 1,
         col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
         main = paste0(  paste0( "Distribution of K for gamma1=gamma2=2 and Lambda varying") ))
```





### gamma1 = gamma2 = 0.1

Ripeto lo stesso esperimento abbassando il valore di $\gamma_1$ e $\gamma_2$. Ogni curva, corrisponde ad aumentare $\Lambda$ di 1.

```{r}
Npoints = 20
gamma1 <- gamma2 <- 0.1
Lambda_grid  = seq(1,20,length.out = Npoints)
prob_k4 = matrix(nrow = Npoints, ncol = n_j)

for(i in 1:Npoints){
  
  #threshold = 0.995
  for(kk in 1:max(n_j) ){
    prob_k4[i,kk] = p_distinct_prior(k = kk, n_j = n_j, 
                                     gamma = c(gamma1,gamma2),
                                     prior = "Poisson", 
                                     lambda = Lambda_grid[i])
    #if(sum(prob_k)>=threshold)
      #break
  }
}
```

La curva nera è la prima, quella con $\Lambda$ minore. Ogni curva, corrisponde ad aumentare $\Lambda$ di 1.

```{r}
par(mar = c(2,2,4,1), bty = "l")
matplot( t(prob_k4), type = "l", lwd = 2,xlim = c(0,35),lty = 1,
         col = c("black",hcl.colors(n=Npoints, palette = "Zissou 1")),
         main = paste0(  paste0( "Distribution of K for gamma1=gamma1=0.1 and Lambda varying") ))
```

