# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' GDFMM sampler
GDFMM_sampler_c <- function(dat, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, option) {
    .Call(`_GDFMM_GDFMM_sampler_c`, dat, n_iter, burn_in, thin, seed, P0_prior_name, FixPart, option)
}

#' Falling Factorial - Raf
#'
#' @export
falling_factorial <- function(x, n) {
    .Call(`_GDFMM_falling_factorial`, x, n)
}

#' Compute Non Central C number - Direct formula Raf
#'
#' Compute the Charalambides non central C numbers using the direct formula, i.e the (2.60) one in the "Combinatorial methods in discrete distributions" book.
#' This version works for r and gamma real numbers, not only positive. However, it is unstable.
#' It computes the whole sequence, C(n,k,gamma,r) for k=0,...,n
#' @export
calcola_stirling <- function(n, gamma, r) {
    .Call(`_GDFMM_calcola_stirling`, n, gamma, r)
}

#' Compute Non Central C number - Recursive formula Raf
#'
#' Compute the Charalambides non central C numbers using the recursive formula, i.e the (2.67) one in the "Combinatorial methods in discrete distributions" book.
#' This version works for r and gamma real numbers, not only positive. However, it is not in log scale, therefore its usage is limited to small n cases.
#' It computes the whole sequence, C(n,k,gamma,r) for k=0,...,n.
#' @export
calcola_stirling_ricor <- function(n, gamma, r) {
    .Call(`_GDFMM_calcola_stirling_ricor`, n, gamma, r)
}

#' Compute Central C number - Recursive formula Raf
#'
#' Same as \code{\link{calcola_stirling_ricor}} but with r=0, i.e for central numbers only.
#' @export
calcola_stirling_ricor_centr <- function(gamma, n) {
    .Call(`_GDFMM_calcola_stirling_ricor_centr`, gamma, n)
}

#' Compute log of absolute values of non Central C number - Recursive formula for Raf
#'
#' \loadmathjax This is the main function in the computation of C numbers. It uses the (2.69) formula in the "Combinatorial methods in discrete distributions" book.
#' It computes \mjseqn{|C(n,k;-\gamma,-r)|} for each k=0,...,n. \mjseqn{\gamma} and r have to be positive. 
#' Attenzione nota importante. Questa in posizione (n,0) ha sempre lo stesso valore ed è pari al fattoriale decrescente (r)1. Ci sono due cose che non tornano,
#' prima di tutto il fatto che sia sempre uguale e poi che sia il fattoriale decrescente. In base alla relazione 
#' \mjsdeqn{(a + n -1)_{n} = (a)^{n}}, quello dovrebbe essere un raising factorial.
#' @export
calcola_stirling_ricor_log <- function(n, gamma, r) {
    .Call(`_GDFMM_calcola_stirling_ricor_log`, n, gamma, r)
}

#' Compute log of absolute values of Central C number - Recursive formula for Raf
#'
#' Same as \code{\link{calcola_stirling_ricor_log}} but with r=0, i.e for central numbers only.
#' @export
calcola_stirling_ricor_log_centrali <- function(n, gamma) {
    .Call(`_GDFMM_calcola_stirling_ricor_log_centrali`, n, gamma)
}

#' Rigon - lgfactorial
#'
#' @export
lgfactorial <- function(n, sigma) {
    .Call(`_GDFMM_lgfactorial`, n, sigma)
}

#' Rigon - lgfactorials
#'
#' @export
lgfactorials <- function(n, sigma) {
    .Call(`_GDFMM_lgfactorials`, n, sigma)
}

#' Rigon - lgfactorial_ns
#'
#' @export
lgfactorial_ns <- function(n, sigma) {
    .Call(`_GDFMM_lgfactorial_ns`, n, sigma)
}

#' Rigon - lastirling1
#'
#' Commento Ale: questa fuzione restituisce il vettore contenente il logaritmo dell'intero sviluppo dei moduli di un
#' numero di Stirling del primo tipo. 
#' Per esempio, per n=4, ho |s(n,0)| = 0, |s(n,1)| = 6, |s(n,2)|= 11, |s(n,3)| = 6, |s(n,4)| = 4.
#' Quindi, lo sviluppo di 4 è un vettore di 4 elementi (lo 0 è banale, lo omettiamo) 
#' @export
lastirling1 <- function(n) {
    .Call(`_GDFMM_lastirling1`, n)
}

#' Rigon - lastirlings1
#'
#' Commento Ale, questa è l'estensione di lastirling1. Questa ritorna una matrice triangolare inferiori, l'argomento n
#' vuol dire che deve calcolare tutti gli sviluppi fino ad n, partendo da s(1) che è banalmente uguale ad uno. Anche
#' questa lavora in scala logaritmica.
#' @export
lastirlings1 <- function(n) {
    .Call(`_GDFMM_lastirlings1`, n)
}

#' Eigen library usage example
#'
#' @export
EigenTest <- function() {
    invisible(.Call(`_GDFMM_EigenTest`))
}

#' Testing GSL wrappers
#'
#' @export
TestGSL <- function() {
    invisible(.Call(`_GDFMM_TestGSL`))
}

#' Calcola Stirling
#'
#' @export
calcola_stirling_old <- function(gamma, n) {
    .Call(`_GDFMM_calcola_stirling_old`, gamma, n)
}

#' Calcola Stirling Ricorsivo
#'
#' @export
calcola_stirling_ricor_old <- function(gamma, n) {
    .Call(`_GDFMM_calcola_stirling_ricor_old`, gamma, n)
}

#' Calcola Stirling Ricorsivo Abs
#'
#' @export
calcola_stirling_ricor_abs_old <- function(gamma, n) {
    .Call(`_GDFMM_calcola_stirling_ricor_abs_old`, gamma, n)
}

#' Calcola Stirling Ricorsivo Log
#'
#' @export
calcola_stirling_ricor_log_old <- function(gamma, n) {
    .Call(`_GDFMM_calcola_stirling_ricor_log_old`, gamma, n)
}

#' Calcola Fattoriale Generalizzato Ricorsivo Log
#'
#' @export
calcola_generalized_factorial_ricor_log_old <- function(gamma, n) {
    .Call(`_GDFMM_calcola_generalized_factorial_ricor_log_old`, gamma, n)
}

#' Calcola Fattoriale Generalizzato Ricorsivo Log Matrice
#'
#' @export
calcola_generalized_factorial_ricor_log_matrice_old <- function(gamma, n) {
    .Call(`_GDFMM_calcola_generalized_factorial_ricor_log_matrice_old`, gamma, n)
}

#' Title Rcpp function
#'
#' @export
try_rcpp <- function(x) {
    .Call(`_GDFMM_try_rcpp`, x)
}

#' Raising Factorial
#'
#' \loadmathjax This function computes the rising factorial \mjseqn{(a)^{n}} using the gsl code for the Pochhammer symbol, i.e
#' \mjsdeqn{(a)^{n} = \frac{\Gamma(a+n)}{\Gamma(a)}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
#' @export
raising_factorial <- function(n, a) {
    .Call(`_GDFMM_raising_factorial`, n, a)
}

#' Falling Factorial
#'
#' \loadmathjax This function computes the falling factorial \mjseqn{ a_{n} }. See \code{\link{raising_factorial}} for details.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
#' @export
my_falling_factorial <- function(n, a) {
    .Call(`_GDFMM_my_falling_factorial`, n, a)
}

#' Pochhammer Symbol
#'
#' \loadmathjax This function computes the Pochhammer symbol, 
#' \mjsdeqn{(a)^{x} = \frac{\Gamma(a+x)}{\Gamma(a)}}.
#' Where \code{x} is a real number. When x is an integer, such a function coincides with the rising factorial defined in \code{\link{raising_factorial}}.
#' The raising (here denote with the upper apex) and the falling factorial (here denote with the lower apex) are related by the following relationship
#' \mjsdeqn{(a)_{n} = (-1)^{n}(a)^{n}}.
#' @export
compute_Pochhammer <- function(x, a) {
    .Call(`_GDFMM_compute_Pochhammer`, x, a)
}

#' Build matrix of logC numbers
#'
#' This is the recursive function called by \code{\link{my_logC}} that builds the matrix containing all the log(|C(n,k)|) numbers.
#' It gets as input the element (n,k) to build, the scale s and location r (here defined as positive and non-negative numbers) and the
#' matrix res to be build. The matrix is constructed diagonal by diagonal, starting from the bottom.
#' Important remark, note that log(|C(n,0)|) = log(raising factorial (n,r)). 
#'
build_logC_matrix <- function(n, k, s, r, res) {
    invisible(.Call(`_GDFMM_build_logC_matrix`, n, k, s, r, res))
}

#' My logC
#'
#' This function is the recursive formula 2.69 in "Combinatorial methods in discrete distributions" book by Charalambides. 
#' It returns an (n+1 x n+1) matrix containing all the log(|C(nn,k)|) numbers, for nn = 0,...,n+1 and k = 0,...,nn. 
#' scale and location must be negative and non-positive, respectively.
#' As a consequence, it is memory expensive.
#' @export
my_logC <- function(n, scale, location) {
    .Call(`_GDFMM_my_logC`, n, scale, location)
}

#' Compute log of absolute values of non Central C number 
#'
#' \loadmathjax This is the main function in the computation of C numbers. It uses the (2.69) formula in the "Combinatorial methods in discrete distributions" book.
#' It computes \mjseqn{log(|C(n,k; scale, location)|)} for each k=0,...,n. 
#' scale and location must be negative and non-positive, respectively.
#' It uses eigen objects, apparetly it is slower than using Rcpp vectors.
#' @export
my_logC2 <- function(n, scale, location) {
    .Call(`_GDFMM_my_logC2`, n, scale, location)
}

#' My logC2 - central
#'
#' This function is the recursive formula 2.69 in "Combinatorial methods in discrete distributions" book by Charalambides for central numbers.
#' This is the specialization of \code{\link{my_logC2}} for central C numbers.
#' scale must be negative.
#' @export
my_logC2_central <- function(n, scale) {
    .Call(`_GDFMM_my_logC2_central`, n, scale)
}

#' compute_logC - Compute log of absolute values of non Central C number 
#'
#' \loadmathjax This is the main function in the computation of C numbers. It uses the (2.69) formula in the "Combinatorial methods in discrete distributions" book.
#' It computes \mjseqn{log(|C(n,k; scale, location)|)} for each k=0,...,n. 
#' This implementation uses Rcpp vectors.
#' @param scale must be strictly negative.
#' @param locatio must be non positive. Set to 0 for central C numbers.
#' @export
compute_logC <- function(n, scale, location) {
    .Call(`_GDFMM_compute_logC`, n, scale, location)
}

